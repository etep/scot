newly added/modified grammar will be explained for now...

1. There is a _NEW_ section in .sp file called optimization section,
which starts with .OPTIMIZE and ends with .ENDS.
(thus we do not specifiy objective statement in the global constraint
section anymore. )

The syntax is as follows.

.OPTIMIZE
{opt_statements}
.ENDS

where {opt_statements} consists of one or more than one {opt_statment}, i.e.

{opt_statements} : {opt_statement}
	| {opt_statements} {opt_statement}

(here | means OR)

where the syntax for opt_statement is

{opt_statement} : minimize A ( optname = {name} ) ;
	| minimize P ( optname = {name} );
	| minimize D ( optname = {name} );
	| minimize D ( optname = {name}, iter = {pinumber}, N = {pinumber}, p = {pnumber} );
	| minimize D ( optname = {name}, iter = {pinumber}, N = {pinumber}, p = {pnumber}, dist = {distribution} );

where	{name} specifies the name of each optimization task,
	{pinumber} denotes positive integer number,
	{pnumber} denotes positive real number,
	{distribution} specifies the distribution of the delay model,
	iter means the number of iterations for statistical optimization,
	p means the quantile point minimzied for statistical optimization,
and	N means the number of Monte Carlo simulation used in the optimization.

As one can see, we _CAN_ specify more than one optimization tasks
in one .sp file,
and 'ciropt' sequantially carries over these optimization
and store results under name of {opt_name}DET.out if it is a determinitic optimization, and {opt_name}STT{num}.out if it is a statistical optimization.
As can be easily understood, the first three lines indicates determinitic opt.
and the rest two lines for statistical opt.


2. Now we have a new constraint statement for slop constraint via delay cosntraint in each gate in global constraints section as before.
The newly added syntax is as follows.

{constraint}: D ( {name} ) < {pnumber} ;
	| D( {name} , rf ) < {pnumber} ;
	| D( {name} , fr ) < {pnumber} ;
	| D( {name} , {pnumber} ) < {pnumber} ;
	| D( {name} , rf, {pnumber} ) < {pnumber} ;
	| D( {name} , fr, {pnumber} ) < {pnumber} ;

where {name} indicates the name of the gate of consideration unless it is "all",
	and if {name} is "all", it means this applies to the all gates.

The caveat is that one line can overwrite a part of another. 
For examples, suppose that we have a total of three gates named nand1, nand2,
and nand3, and we have the following global constraints.

D( nand1 ) < 3;
D( all ) < 2;

Then this is quivalent to

D( nand1 ) < 3;
D( nand2 ) < 2;
D( nand3 ) < 2;

EVEN IF "D(all) < 2;" came later than "D(nana1)<3".
Hence the precedence for these statement has nothing to do with their
physical order in the .sp file, but goes as follows.

D( {gate_name}, rf _or_ fr ) < {pnumber};
D( {gate_name} ) < {pnumber};
D( all, rf _or_ fr ) < {pnumber};
D( all ) < {pnumber};

meaning that the former overwrites the corresponding part of the latter.

Lastly, for example,
D( nand1, rf, .9 ) < 2;
means the 90%-quantile point of rise-to-fall delays of the gate1 for each input
must be less than 2.

and the precedence for these is almost the same as before, i.e.

D( {gate_name}, rf _or_ fr, {pnumber} ) < {pnumber};
D( {gate_name}, {pnumber} ) < {pnumber};
D( all, rf _or_ fr, {pnumber} ) < {pnumber};
D( all, {pnumber} ) < {pnumber};

::::::::::::::
sam1.sp
::::::::::::::
** FILE: sample_spice.sp
*
******************* default header for EE315 ******************
* setting process file
* .protect
* .lib 'log018.l' TT
* .unprotect
**
** * setting supply
* .param supply = 1.8
**
** * setting lambda
* .opt scale = 0.03u
**
*.option accurate
*
** * generate .tr0 file
* .options post
**
** *********************** end header ******************************
* 
*UNITS ***************************
*THE CAPS IS IN fF UNLESS MENTIONED OTHERWISE
*TIME IS IN ns UNLESS MENTIONED OTHERWISE
*WIDTH IS IN um UNLESS MENTIONED OTHERWISE
*CURRENT IS IN uA UNLESS MENTIONED OTHERWISE

* SPICE netlist for "sample_spice" (generated by MMI_SUE2.5)

.GLBPARAM
CovN = 0.3665;
CovP = 0.328;
CparN_r_edge =  0.1797;
CparP_r_edge = 0.2078;
CparN_r_width = 1.3241;
CparP_r_width = 1.33;
CparN_f_edge = 0.1632;
CparP_f_edge = 0.1706;
CparN_f_width= 1.2348;
CparP_f_width = 1.193;
idr_rise = 218.4;
idr_fall = 642.3;
Vdd = 1.8;
.ENDS

.SUBCKT t_nand2 out in1 in2 WP=42 LP=6 WN=21 LN=6;
M_0 out in1 int1 gnd nmos W=M_0.WN L=LN GEO=2;
M_1 int1 in2 gnd gnd nmos W=M_1.WN L=LN GEO=1;
M_2 out in2 Vdd Vdd pmos W=M_2.WP L=LP GEO=2;
M_3 out in1 Vdd Vdd pmos W=M_3.WP L=LP GEO=2; 
.ENDS

.SUBCKT t_inv out in  WP=42 LP=6 WN=14 LN=6;
M_0 out in vdd vdd pmos W=M_0.WP L=LP GEO=0;
M_1 out in gnd gnd nmos W=M_1.WN L=LN GEO=0;
.ENDS

.SUBCKT t_nor2 out in1 in2  WP=60 LP=6 WN=14 LN=6;
M_0 int1 in1 Vdd Vdd pmos W=M_0.WP L=LP GEO=1;
M_1 out in2 int1 Vdd pmos W=M_1.WP L=LP GEO=2; 
M_2 out in2 gnd gnd nmos W=M_2.WN L=LN GEO=1; 
M_3 out in1 gnd gnd nmos W=M_3.WN L=LN GEO=1; 
.ENDS	

* start main CELL sample_spice
* .SUBCKT sample_spice in1 in2 in3 in4 out1 out2 out3 
.CONNECT
Xt_nor21 n4 out1 n2 : t_nor2
out1.Xt_nor21.M_0.WP out1.Xt_nor21.M_3.WN n2.Xt_nor21.M_2.WN n2.Xt_nor21.M_1.WP;

Xt_inv13 n2 in3 : t_inv
in3.Xt_inv13.M_0.WP in3.Xt_inv13.M_1.WN;
*in3.Xt_inv13.WP in3.Xt_inv13.WN;

Xt_inv21 out3 n4 : t_inv
n4.Xt_inv21.M_0.WP n4.Xt_inv21.M_1.WN;
*n4.Xt_inv21.WP n4.Xt_inv21.WN;

Xt_nand229 out1 net_1 in2 : t_nand2
net_1.Xt_nand229.M_0.WN net_1.Xt_nand229.M_3.WP in2.Xt_nand229.M_2.WP in2.Xt_nand229.M_1.WN;

Xt_inv38 n3 in4 : t_inv
in4.Xt_inv38.M_0.WP in4.Xt_inv38.M_1.WN;
*in4.Xt_inv38.WP in4.Xt_inv38.WN;

Xt_nand246 out2 n4 n3: t_nand2
n4.Xt_nand246.M_0.WN n4.Xt_nand246.M_3.WP n3.Xt_nand246.M_2.WP n3.Xt_nand246.M_1.WN;

Xt_inv132 net_1 in1: t_inv
in1.Xt_inv132.M_0.WP in1.Xt_inv133.M_1.WN;
*in1.Xt_inv132.WP in1.Xt_inv133.WN;

C_1 gnd out2 c=800;
*C_1 gnd out2 800fF;
C_2 gnd out1 c=100;
.ENDS
* .ENDS	$ sample_spice

*LIST OF GLOBAL PARAMETERS THAT YOU WILL USE FOR FORMING THE LOAD AND SOME OTHERS THAT WILL BE USED LATER.
.GLBPARAM
CgateP_rise = 1.98;
CgateP_fall = 1.35;
CgateN_rise = 1.5;
CgateN_fall = 2.03;
Vthn = 0.635;
Vthp = 0.754;
.ENDS

* Input cap allowed
.PI
name=in1, at=10.0, s=(0.02,0.02), c = 10;
*name=in1, at=0.0, s=(0.02,0.02), c = 5;
name=in2, at=10.0, s=(0.2,0.1), c = 8;
name=in3, at=10.0, s=(0.1,0.05), c = 10;
name=in4, at=10.0, s=(0.1,0.2), c = 6;
.ENDS

*primary outputs followed by loads at each output
.PO
name=out1, c=1e3;
**name=out1, c=100;
name=out2, c=800;
name=out3, c=1e3;
.ENDS


.GLBCNSTR
*constraints on area power delay ... the functions and interpretation is assumed to be known to the opt people
*A in um^2 P in mW
*A < 200.0;
*A < opt;
*minimize D;
*D < 100.0;

*Drf(all) < 0.3;

D(Xt_nand229,.8) < 10000.0;
D(all) < 100.0;


*the opt symbol above indicates to the optimizer what the objective function is...
* Also later on we can introduce D(in1, out2) < 2 etc kind of specialized timing constraints,,


*Now constraints on the widths of devices..
* some will be internal some external...does not matter 
*Xt_nor21.M_0.WP = Xt_nor21.M_1.WP;
*Xt_nor21.M_3.WN = Xt_nor21.M_2.WN;

**etc etc..

*Max width constraints,,,
Xt_nor21.M_0.WP < 6;

**etc etc..

*Slope constraints (basically delay constraints on individual nets)
t_rise(n3) < 14;
t_fall(n2) < 14;

.ENDS

.OPTIMIZE
minimize D(optname=first);
minimize D(optname=second,iter=5,N=10000,p=0.9,dist=normal);
.ENDS

*etc etc..

*Noise constraints...I dont know if these are convex constraints...so I am not putting them 
* basically they say that abs(rise_time(any_node) - fall_time(the same node)) < some amount


* further poissible constraints...now that we have global variables in our hand...that should be convenient.


* XXX: format change for connectivity
* XXX: capacitor expressoin change in connectivity section
* XXX: add DELIMITER in subcircuit description section
* XXX: add DELIMITER in global parameters section
* XXX: which one is slope_r and which is slope_f?
* XXX: mention the wrong description for the node Xt_inv13
* XXX: mention the mistake in po description and clarification of ou2!

* XXX: input c m....
* XXX: send this file right away!
::::::::::::::
sam1.dio
::::::::::::::
t_nand2.in1
rf :  (0.1632 + 1.6013 * M_0.WN + 0.1706 + 1.5210 * M_2.WP + 0.1706 + 1.5210 * M_3.WP+_LOAD_F_)*(1.444e-3*max(M_1.WN^-1, M_0.WN^-1) + 1.047e-3*(M_1.WN^-1 + M_0.WN^-1));

std : (0.1632 + 1.6013 * M_0.WN + 0.1706 + 1.5210 * M_2.WP + 0.1706 + 1.5210 * M_3.WP+_LOAD_F_)*(1.444e-3*max(M_1.WN^-1, M_0.WN^-1) + 1.047e-3*(M_1.WN^-1 + M_0.WN^-1));

fr :  (0.1797 + 1.6906 * M_0.WN + 0.2078 + 1.6580 * M_2.WP + 0.2078 + 1.6580 * M_3.WP+_LOAD_R_)*(1.277/(218.4*M_3.WP));
std : (0.1797 + 1.6906 * M_0.WN + 0.2078 + 1.6580 * M_2.WP + 0.2078 + 1.6580 * M_3.WP+_LOAD_R_)*(1.277/(218.4*M_3.WP));

t_nand2.in2
rf :  (0.1632 + 1.6013 * M_0.WN + 0.1706 + 1.5210 * M_2.WP + 0.1706 + 1.5210 * M_3.WP+_LOAD_F_)*(1.444e-3*max(M_1.WN^-1, M_0.WN^-1) + 1.047e-3*(M_1.WN^-1 + M_0.WN^-1)) +  (0.1632 + 1.6013 * M_0.WN + 0.1632 + 1.6013 * M_1.WN)*(1.218/(642.3*M_1.WN));
std : (0.1632 + 1.6013 * M_0.WN + 0.1706 + 1.5210 * M_2.WP + 0.1706 + 1.5210 * M_3.WP+_LOAD_F_)*(1.444e-3*max(M_1.WN^-1, M_0.WN^-1) + 1.047e-3*(M_1.WN^-1 + M_0.WN^-1)) +  (0.1632 + 1.6013 * M_0.WN + 0.1632 + 1.6013 * M_1.WN)*(1.218/(642.3*M_1.WN));
fr :  (0.1797 + 1.6906 * M_0.WN + 0.2078 + 1.6580 * M_2.WP + 0.2078 + 1.6580 * M_3.WP+_LOAD_R_)*(1.277/(218.4*M_2.WP));
std : (0.1797 + 1.6906 * M_0.WN + 0.2078 + 1.6580 * M_2.WP + 0.2078 + 1.6580 * M_3.WP+_LOAD_R_)*(1.277/(218.4*M_2.WP));

t_inv.in
fr :  (0.2078 + 1.6580 * M_0.WP + 0.1797 + 1.6906 * M_1.WN+_LOAD_R_)*(1.277/(218.4*M_0.WP));
std : (0.2078 + 1.6580 * M_0.WP + 0.1797 + 1.6906 * M_1.WN+_LOAD_R_)*(1.277/(218.4*M_0.WP));
rf :  (0.1706 + 1.5210 * M_0.WP + 0.1632 + 1.6013 * M_1.WN+_LOAD_F_)*(1.218/(642.3*M_1.WN));
std : (0.1706 + 1.5210 * M_0.WP + 0.1632 + 1.6013 * M_1.WN+_LOAD_F_)*(1.218/(642.3*M_1.WN));

t_nor2.in1
fr :  (0.2078 + 1.6580 * M_1.WP + 0.1797 + 1.6906 * M_2.WN + 0.1797 + 1.6906 * M_3.WN+_LOAD_R_)*(1.469e-3*max(M_0.WP^-1, M_1.WP^-1) + 5.509e-3*(M_0.WP^-1 + M_1.WP^-1)) +  (0.2078 + 1.6580 * M_0.WP + 0.2078 + 1.6580 * M_1.WP)*(1.277/(218.4*M_0.WP));
std : (0.2078 + 1.6580 * M_1.WP + 0.1797 + 1.6906 * M_2.WN + 0.1797 + 1.6906 * M_3.WN+_LOAD_R_)*(1.469e-3*max(M_0.WP^-1, M_1.WP^-1) + 5.509e-3*(M_0.WP^-1 + M_1.WP^-1)) +  (0.2078 + 1.6580 * M_0.WP + 0.2078 + 1.6580 * M_1.WP)*(1.277/(218.4*M_0.WP));
rf :  (0.1706 + 1.5210 * M_1.WP + 0.1632 + 1.6013 * M_2.WN + 0.1632 + 1.6013 * M_3.WN+_LOAD_F_)*(1.218/(642.3*M_3.WN));
std : (0.1706 + 1.5210 * M_1.WP + 0.1632 + 1.6013 * M_2.WN + 0.1632 + 1.6013 * M_3.WN+_LOAD_F_)*(1.218/(642.3*M_3.WN));

t_nor2.in2
fr :  (0.2078 + 1.6580 * M_1.WP + 0.1797 + 1.6906 * M_2.WN + 0.1797 + 1.6906 * M_3.WN+_LOAD_R_)*(1.469e-3*max(M_0.WP^-1, M_1.WP^-1) + 5.509e-3*(M_0.WP^-1 + M_1.WP^-1));
std : (0.2078 + 1.6580 * M_1.WP + 0.1797 + 1.6906 * M_2.WN + 0.1797 + 1.6906 * M_3.WN+_LOAD_R_)*(1.469e-3*max(M_0.WP^-1, M_1.WP^-1) + 5.509e-3*(M_0.WP^-1 + M_1.WP^-1));
rf :  (0.1706 + 1.5210 * M_1.WP + 0.1632 + 1.6013 * M_2.WN + 0.1632 + 1.6013 * M_3.WN+_LOAD_F_)*(1.218/(642.3*M_2.WN));
std : (0.1706 + 1.5210 * M_1.WP + 0.1632 + 1.6013 * M_2.WN + 0.1632 + 1.6013 * M_3.WN+_LOAD_F_)*(1.218/(642.3*M_2.WN));
